use std::ffi::OsStr;
use std::os::windows::ffi::OsStrExt;
use std::ptr;
use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};
use windows::{
    Win32::Foundation::*, Win32::NetworkManagement::WindowsFilteringPlatform::*,
    Win32::System::Rpc::*, core::*,
};

// CIDRÁΩëÊÆµÁªìÊûÑ‰Ωì
#[derive(Debug, Clone)]
pub struct IpNetwork {
    pub ip: IpAddr,
    pub prefix_len: u8,
}

impl IpNetwork {
    pub fn new(ip: IpAddr, prefix_len: u8) -> Self {
        Self { ip, prefix_len }
    }
    
    pub fn from_cidr(cidr: &str) -> std::result::Result<Self, String> {
        let parts: Vec<&str> = cidr.split('/').collect();
        if parts.len() != 2 {
            return Err("Invalid CIDR format".to_string());
        }
        
        let ip: IpAddr = parts[0].parse().map_err(|_| "Invalid IP address")?;
        let prefix_len: u8 = parts[1].parse().map_err(|_| "Invalid prefix length")?;
        
        // È™åËØÅÂâçÁºÄÈïøÂ∫¶
        let max_prefix = match ip {
            IpAddr::V4(_) => 32,
            IpAddr::V6(_) => 128,
        };
        
        if prefix_len > max_prefix {
            return Err(format!("Prefix length {} exceeds maximum {}", prefix_len, max_prefix));
        }
        
        Ok(Self::new(ip, prefix_len))
    }
    
    pub fn contains(&self, ip: &IpAddr) -> bool {
        match (self.ip, ip) {
            (IpAddr::V4(network_ip), IpAddr::V4(test_ip)) => {
                let mask = !((1u32 << (32 - self.prefix_len)) - 1);
                let network_addr = u32::from(network_ip) & mask;
                let test_addr = u32::from(*test_ip) & mask;
                network_addr == test_addr
            }
            (IpAddr::V6(network_ip), IpAddr::V6(test_ip)) => {
                let network_bytes = network_ip.octets();
                let test_bytes = test_ip.octets();
                let prefix_bytes = self.prefix_len / 8;
                let prefix_bits = self.prefix_len % 8;
                
                // ÊØîËæÉÂÆåÊï¥Â≠óËäÇ
                for i in 0..prefix_bytes as usize {
                    if network_bytes[i] != test_bytes[i] {
                        return false;
                    }
                }
                
                // ÊØîËæÉÈÉ®ÂàÜÂ≠óËäÇ
                if prefix_bits > 0 {
                    let mask = 0xFF << (8 - prefix_bits);
                    let network_byte = network_bytes[prefix_bytes as usize] & mask;
                    let test_byte = test_bytes[prefix_bytes as usize] & mask;
                    if network_byte != test_byte {
                        return false;
                    }
                }
                
                true
            }
            _ => false, // IPv4 vs IPv6 ‰∏çÂåπÈÖç
        }
    }
}

// WFP Â∏∏ÈáèÂÆö‰πâ
const FWP_ACTION_BLOCK: u32 = 0x00000001 | 0x00001000;
const FWP_ACTION_PERMIT: u32 = 0x00000002 | 0x00001000;
static mut WEIGHT_VALUE: u64 = 1000;
static mut EFFECTIVE_WEIGHT_VALUE: u64 = 0;

// ËøáÊª§ËßÑÂàôÁªìÊûÑ‰Ωì
#[derive(Debug, Clone)]
pub struct FilterRule {
    pub name: String,
    pub app_path: Option<String>,
    pub local_ip: Option<IpAddr>,
    pub remote_ip: Option<IpAddr>,
    pub local_ip_network: Option<IpNetwork>,
    pub remote_ip_network: Option<IpNetwork>,
    pub local_port: Option<u16>,
    pub remote_port: Option<u16>,
    pub protocol: Option<Protocol>,
    pub direction: Direction,
    pub action: FilterAction,
}

#[derive(Debug, Clone)]
pub enum Protocol {
    Tcp,
    Udp,
    Icmp,
}

// ÊµÅÈáèÊñπÂêëÊûö‰∏æ
#[derive(Debug, Clone)]
pub enum Direction {
    Inbound,     // ÂÖ•Á´ôÊµÅÈáè
    Outbound,    // Âá∫Á´ôÊµÅÈáè
    Both,        // ÂèåÂêëÊµÅÈáè
}
#[derive(Debug, Clone)]
pub enum FilterAction {
    Allow,
    Block,
}

impl FilterRule {
    pub fn new(name: &str) -> Self {
        Self {
            name: name.to_string(),
            app_path: None,
            local_ip: None,
            remote_ip: None,
            local_ip_network: None,
            remote_ip_network: None,
            local_port: None,
            remote_port: None,
            protocol: None,
            direction: Direction::Both,
            action: FilterAction::Block,
        }
    }

    pub fn app_path(mut self, path: &str) -> Self {
        self.app_path = Some(path.to_string());
        self
    }

    pub fn local_ip(mut self, ip: IpAddr) -> Self {
        self.local_ip = Some(ip);
        self
    }

    pub fn remote_ip(mut self, ip: IpAddr) -> Self {
        self.remote_ip = Some(ip);
        self
    }

    pub fn local_ip_network(mut self, network: IpNetwork) -> Self {
        self.local_ip_network = Some(network);
        self
    }

    pub fn remote_ip_network(mut self, network: IpNetwork) -> Self {
        self.remote_ip_network = Some(network);
        self
    }

    pub fn local_ip_cidr(mut self, cidr: &str) -> std::result::Result<Self, String> {
        self.local_ip_network = Some(IpNetwork::from_cidr(cidr)?);
        Ok(self)
    }

    pub fn remote_ip_cidr(mut self, cidr: &str) -> std::result::Result<Self, String> {
        self.remote_ip_network = Some(IpNetwork::from_cidr(cidr)?);
        Ok(self)
    }

    pub fn local_port(mut self, port: u16) -> Self {
        self.local_port = Some(port);
        self
    }

    pub fn remote_port(mut self, port: u16) -> Self {
        self.remote_port = Some(port);
        self
    }

    pub fn protocol(mut self, protocol: Protocol) -> Self {
        self.protocol = Some(protocol);
        self
    }

    pub fn direction(mut self, direction: Direction) -> Self {
        self.direction = direction;
        self
    }

    pub fn action(mut self, action: FilterAction) -> Self {
        self.action = action;
        self
    }
}

// ÂàõÂª∫ÂÆΩÂ≠óÁ¨¶Â≠óÁ¨¶‰∏≤ÁöÑËæÖÂä©ÂáΩÊï∞
pub fn to_wide_string(s: &str) -> Vec<u16> {
    OsStr::new(s)
        .encode_wide()
        .chain(std::iter::once(0))
        .collect()
}

// WFPÊéßÂà∂Âô®ÁªìÊûÑ‰Ωì
pub struct WfpController {
    engine_handle: HANDLE,
    filter_ids: Vec<u64>,
}

impl WfpController {
    // ÂàõÂª∫Êñ∞ÁöÑWFPÊéßÂà∂Âô®ÂÆû‰æã
    pub fn new() -> Result<Self> {
        Ok(Self {
            engine_handle: HANDLE::default(),
            filter_ids: Vec::new(),
        })
    }

    // ÂàùÂßãÂåñWFPÂºïÊìé
    pub fn initialize(&mut self) -> Result<()> {
        unsafe {
            println!("Ê≠£Âú®ÂàùÂßãÂåñ Windows Filtering Platform...");

            // ÂàõÂª∫‰ºöËØùÂêçÁß∞
            let session_name = to_wide_string("AstralWFP Manager");
            let session_desc = to_wide_string("AstralWFPÁΩëÁªúÊµÅÈáèÁÆ°ÁêÜ‰ºöËØù");

            let session = FWPM_SESSION0 {
                sessionKey: GUID::zeroed(),
                displayData: FWPM_DISPLAY_DATA0 {
                    name: PWSTR(session_name.as_ptr() as *mut u16),
                    description: PWSTR(session_desc.as_ptr() as *mut u16),
                },
                flags: FWPM_SESSION_FLAG_DYNAMIC,
                txnWaitTimeoutInMSec: 0,
                processId: 0,
                sid: ptr::null_mut(),
                username: PWSTR::null(),
                kernelMode: FALSE,
            };

            // ÊâìÂºÄWFP‰ºöËØù
            let result = FwpmEngineOpen0(
                None,
                RPC_C_AUTHN_DEFAULT as u32,
                None,
                Some(&session),
                &mut self.engine_handle,
            );

            if WIN32_ERROR(result) == ERROR_SUCCESS {
                println!("‚úì WFPÂºïÊìéÊâìÂºÄÊàêÂäüÔºÅ");
                Ok(())
            } else {
                println!("‚ùå ÊâìÂºÄWFPÂºïÊìéÂ§±Ë¥•: {} (ÂèØËÉΩÈúÄË¶ÅÁÆ°ÁêÜÂëòÊùÉÈôê)", result);
                Err(Error::from_win32())
            }
        }
    }


    // Ê∑ªÂä†È´òÁ∫ßËøáÊª§Âô®ÔºàÊîØÊåÅÂ§çÊùÇËßÑÂàôÔºâ
    pub fn add_advanced_filters(&mut self, rules: &[FilterRule]) -> Result<()> {
        unsafe {
            let mut added_count = 0;
            
            for rule in rules {
                // Ê†πÊçÆÊñπÂêëÂíåIPÁâàÊú¨Á°ÆÂÆöÈúÄË¶ÅÁöÑÂ±Ç
                let layers = self.get_layers_for_rule(rule);
                
                for layer in layers {
                    if let Ok(filter_id) = self.add_advanced_network_filter(rule, layer) {
                        self.filter_ids.push(filter_id);
                        added_count += 1;
                        println!("‚úì {}ËøáÊª§Âô®Ê∑ªÂä†ÊàêÂäü (ID: {}) - Â±Ç: {:?}", rule.name, filter_id, layer);
                    }
                }
            }

            if added_count > 0 {
                println!(
                    "\nüîç ÁΩëÁªúÊµÅÈáèÊéßÂà∂Â∑≤ÂêØÂä®ÔºåÂÖ±Ê∑ªÂä†‰∫Ü {} ‰∏™ËøáÊª§Âô®",
                    added_count
                );
                Ok(())
            } else {
                println!("‚ùå Ê≤°ÊúâÊàêÂäüÊ∑ªÂä†‰ªª‰ΩïËøáÊª§Âô®");
                Err(Error::from_win32())
            }
        }
    }

    // Ê†πÊçÆËßÑÂàôËé∑ÂèñÂØπÂ∫îÁöÑWFPÂ±Ç
    fn get_layers_for_rule(&self, rule: &FilterRule) -> Vec<GUID> {
        let mut layers = Vec::new();
        
        // Ê†πÊçÆIPÂú∞ÂùÄÁ±ªÂûãÂíåÊñπÂêëÁ°ÆÂÆöÂ±Ç
        let is_ipv6 = rule.local_ip.map_or(false, |ip| ip.is_ipv6()) || 
                     rule.remote_ip.map_or(false, |ip| ip.is_ipv6());
        
        match rule.direction {
            Direction::Outbound => {
                if is_ipv6 {
                    layers.push(FWPM_LAYER_ALE_AUTH_CONNECT_V6);
                } else {
                    layers.push(FWPM_LAYER_ALE_AUTH_CONNECT_V4);
                }
            },
            Direction::Inbound => {
                if is_ipv6 {
                    layers.push(FWPM_LAYER_ALE_AUTH_RECV_ACCEPT_V6);
                } else {
                    layers.push(FWPM_LAYER_ALE_AUTH_RECV_ACCEPT_V4);
                }
            },
            Direction::Both => {
                if is_ipv6 {
                    layers.push(FWPM_LAYER_ALE_AUTH_CONNECT_V6);
                    layers.push(FWPM_LAYER_ALE_AUTH_RECV_ACCEPT_V6);
                } else {
                    layers.push(FWPM_LAYER_ALE_AUTH_CONNECT_V4);
                    layers.push(FWPM_LAYER_ALE_AUTH_RECV_ACCEPT_V4);
                }
            }
        }
        
        // Â¶ÇÊûúÊ≤°ÊúâÊåáÂÆöIPÁ±ªÂûãÔºåÂêåÊó∂Ê∑ªÂä†IPv4ÂíåIPv6Â±Ç
        if layers.is_empty() {
            match rule.direction {
                Direction::Outbound => {
                    layers.push(FWPM_LAYER_ALE_AUTH_CONNECT_V4);
                    layers.push(FWPM_LAYER_ALE_AUTH_CONNECT_V6);
                },
                Direction::Inbound => {
                    layers.push(FWPM_LAYER_ALE_AUTH_RECV_ACCEPT_V4);
                    layers.push(FWPM_LAYER_ALE_AUTH_RECV_ACCEPT_V6);
                },
                Direction::Both => {
                    layers.push(FWPM_LAYER_ALE_AUTH_CONNECT_V4);
                    layers.push(FWPM_LAYER_ALE_AUTH_RECV_ACCEPT_V4);
                    layers.push(FWPM_LAYER_ALE_AUTH_CONNECT_V6);
                    layers.push(FWPM_LAYER_ALE_AUTH_RECV_ACCEPT_V6);
                }
            }
        }
        
        layers
    }

    // Á≠âÂæÖÁî®Êà∑ËæìÂÖ•Âπ∂ËøêË°å
    pub fn run(&self) -> Result<()> {
        println!("üìä ËøáÊª§Âô®Ê≠£Âú®ËøêË°å...");
        println!("\nÊåâ Enter ÈîÆÂÅúÊ≠¢Âπ∂ÈÄÄÂá∫\n");

        // Á≠âÂæÖÁî®Êà∑ËæìÂÖ•
        let mut input = String::new();
        std::io::stdin().read_line(&mut input).unwrap();
        Ok(())
    }

    // Ê∏ÖÁêÜËøáÊª§Âô®
    pub fn cleanup(&mut self) -> Result<()> {
        unsafe {
            println!("\nüõë ÂÅúÊ≠¢ËøáÊª§Âô®ÔºåÊ≠£Âú®Ê∏ÖÁêÜ...");

            // Ê∏ÖÁêÜËøáÊª§Âô®
            for filter_id in &self.filter_ids {
                let delete_result = FwpmFilterDeleteById0(self.engine_handle, *filter_id);
                if WIN32_ERROR(delete_result) == ERROR_SUCCESS {
                    println!("‚úì ËøáÊª§Âô® {} Â∑≤Âà†Èô§", filter_id);
                } else {
                    println!("‚ö†Ô∏è  Âà†Èô§ËøáÊª§Âô® {} Â§±Ë¥•: {}", filter_id, delete_result);
                }
            }

            // ÂÖ≥Èó≠ÂºïÊìé
            let result = FwpmEngineClose0(self.engine_handle);
            if WIN32_ERROR(result) != ERROR_SUCCESS {
                println!("‚ùå ÂÖ≥Èó≠WFPÂºïÊìéÂ§±Ë¥•: {}", result);
                return Err(Error::from_win32());
            }
            println!("‚úì WFPÂºïÊìéÂ∑≤ÂÖ≥Èó≠");
            Ok(())
        }
    }

    // Ê∑ªÂä†È´òÁ∫ßÁΩëÁªúËøáÊª§Âô®ÁöÑÂÜÖÈÉ®ÊñπÊ≥ï
    unsafe fn add_advanced_network_filter(
        &self,
        rule: &FilterRule,
        layer_key: GUID,
    ) -> Result<u64> {
        // Â∞ÜËøáÊª§Âô®ÂêçÁß∞ËΩ¨Êç¢‰∏∫ÂÆΩÂ≠óÁ¨¶‰∏≤
        let filter_name = to_wide_string(&rule.name);
        // ÁîüÊàêËøáÊª§Âô®ÊèèËø∞Âπ∂ËΩ¨Êç¢‰∏∫ÂÆΩÂ≠óÁ¨¶‰∏≤
        let filter_desc = to_wide_string(&format!("ÊéßÂà∂ {} ÁöÑÁΩëÁªúÊµÅÈáè", rule.name));

        // ÂàõÂª∫ËøáÊª§Êù°‰ª∂ÂêëÈáè
        let mut conditions = Vec::new();
        
        // Ê∑ªÂä†Â∫îÁî®Á®ãÂ∫èË∑ØÂæÑÊù°‰ª∂
        let mut app_id_data = None;
        if let Some(app_path) = &rule.app_path {
            let appid_utf16: Vec<u16> = app_path
                .encode_utf16()
                .chain(std::iter::once(0))
                .collect();
            
            let app_id = FWP_BYTE_BLOB {
                size: (appid_utf16.len() * 2) as u32,
                data: appid_utf16.as_ptr() as *mut u8,
            };
            
            conditions.push(FWPM_FILTER_CONDITION0 {
                fieldKey: FWPM_CONDITION_ALE_APP_ID,
                matchType: FWP_MATCH_EQUAL,
                conditionValue: FWP_CONDITION_VALUE0 {
                    r#type: FWP_BYTE_BLOB_TYPE,
                    Anonymous: FWP_CONDITION_VALUE0_0 {
                        byteBlob: &app_id as *const _ as *mut _,
                    },
                },
            });
            
            app_id_data = Some((appid_utf16, app_id));
            println!("‚úì APP_IDÊù°‰ª∂Â∑≤Ê∑ªÂä†Âà∞ËøáÊª§Âô®: {}", app_path);
        }
        
        // Ê∑ªÂä†Êú¨Âú∞IPÊù°‰ª∂
        let mut local_ip_data = None;
        if let Some(local_ip) = rule.local_ip {
            match local_ip {
                IpAddr::V4(ipv4) => {
                    let ip_bytes = ipv4.octets();
                    let ip_value = u32::from_be_bytes(ip_bytes);
                    
                    conditions.push(FWPM_FILTER_CONDITION0 {
                        fieldKey: FWPM_CONDITION_IP_LOCAL_ADDRESS,
                        matchType: FWP_MATCH_EQUAL,
                        conditionValue: FWP_CONDITION_VALUE0 {
                            r#type: FWP_UINT32,
                            Anonymous: FWP_CONDITION_VALUE0_0 {
                                uint32: ip_value,
                            },
                        },
                    });
                    println!("‚úì Êú¨Âú∞IPv4Âú∞ÂùÄÊù°‰ª∂Â∑≤Ê∑ªÂä†: {}", ipv4);
                },
                IpAddr::V6(ipv6) => {
                    let ip_bytes = ipv6.octets();
                    let byte_array = FWP_BYTE_ARRAY16 {
                        byteArray16: ip_bytes,
                    };
                    
                    conditions.push(FWPM_FILTER_CONDITION0 {
                        fieldKey: FWPM_CONDITION_IP_LOCAL_ADDRESS,
                        matchType: FWP_MATCH_EQUAL,
                        conditionValue: FWP_CONDITION_VALUE0 {
                            r#type: FWP_BYTE_ARRAY16_TYPE,
                            Anonymous: FWP_CONDITION_VALUE0_0 {
                                byteArray16: &byte_array as *const _ as *mut _,
                            },
                        },
                    });
                    local_ip_data = Some(byte_array);
                    println!("‚úì Êú¨Âú∞IPv6Âú∞ÂùÄÊù°‰ª∂Â∑≤Ê∑ªÂä†: {}", ipv6);
                }
            }
        }
        
        // Ê∑ªÂä†ËøúÁ®ãIPÊù°‰ª∂
        let mut remote_ip_data = None;
        if let Some(remote_ip) = rule.remote_ip {
            match remote_ip {
                IpAddr::V4(ipv4) => {
                    let ip_bytes = ipv4.octets();
                    let ip_value = u32::from_be_bytes(ip_bytes);
                    
                    conditions.push(FWPM_FILTER_CONDITION0 {
                        fieldKey: FWPM_CONDITION_IP_REMOTE_ADDRESS,
                        matchType: FWP_MATCH_EQUAL,
                        conditionValue: FWP_CONDITION_VALUE0 {
                            r#type: FWP_UINT32,
                            Anonymous: FWP_CONDITION_VALUE0_0 {
                                uint32: ip_value,
                            },
                        },
                    });
                    println!("‚úì ËøúÁ®ãIPv4Âú∞ÂùÄÊù°‰ª∂Â∑≤Ê∑ªÂä†: {}", ipv4);
                },
                IpAddr::V6(ipv6) => {
                    let ip_bytes = ipv6.octets();
                    let byte_array = FWP_BYTE_ARRAY16 {
                        byteArray16: ip_bytes,
                    };
                    
                    conditions.push(FWPM_FILTER_CONDITION0 {
                        fieldKey: FWPM_CONDITION_IP_REMOTE_ADDRESS,
                        matchType: FWP_MATCH_EQUAL,
                        conditionValue: FWP_CONDITION_VALUE0 {
                            r#type: FWP_BYTE_ARRAY16_TYPE,
                            Anonymous: FWP_CONDITION_VALUE0_0 {
                                byteArray16: &byte_array as *const _ as *mut _,
                            },
                        },
                    });
                    remote_ip_data = Some(byte_array);
                    println!("‚úì ËøúÁ®ãIPv6Âú∞ÂùÄÊù°‰ª∂Â∑≤Ê∑ªÂä†: {}", ipv6);
                }
            }
        }
        
        // Ê∑ªÂä†ËøúÁ®ãIPÁΩëÊÆµÊù°‰ª∂
        let mut remote_network_data = None;
        if let Some(remote_network) = &rule.remote_ip_network {
            match remote_network.ip {
                IpAddr::V4(network_ip) => {
                    let network_bytes = network_ip.octets();
                    let mask = !((1u32 << (32 - remote_network.prefix_len)) - 1);
                    let network_addr = u32::from_be_bytes(network_bytes) & mask;
                    
                    let range = FWP_RANGE0 {
                        valueLow: FWP_VALUE0 {
                            r#type: FWP_UINT32,
                            Anonymous: FWP_VALUE0_0 {
                                uint32: network_addr,
                            },
                        },
                        valueHigh: FWP_VALUE0 {
                            r#type: FWP_UINT32,
                            Anonymous: FWP_VALUE0_0 {
                                uint32: network_addr | !mask,
                            },
                        },
                    };
                    
                    conditions.push(FWPM_FILTER_CONDITION0 {
                        fieldKey: FWPM_CONDITION_IP_REMOTE_ADDRESS,
                        matchType: FWP_MATCH_RANGE,
                        conditionValue: FWP_CONDITION_VALUE0 {
                            r#type: FWP_RANGE_TYPE,
                            Anonymous: FWP_CONDITION_VALUE0_0 {
                                rangeValue: &range as *const _ as *mut _,
                            },
                        },
                    });
                    remote_network_data = Some(range);
                    println!("‚úì ËøúÁ®ãIPv4ÁΩëÊÆµÊù°‰ª∂Â∑≤Ê∑ªÂä†: {}/{}", network_ip, remote_network.prefix_len);
                },
                IpAddr::V6(_) => {
                    println!("‚ö†Ô∏è IPv6ÁΩëÊÆµËøáÊª§ÊöÇ‰∏çÊîØÊåÅÔºåÂ∞ÜË∑≥ËøáÊ≠§Êù°‰ª∂");
                }
            }
        }
        
        // Ê∑ªÂä†Êú¨Âú∞Á´ØÂè£Êù°‰ª∂
        if let Some(local_port) = rule.local_port {
            conditions.push(FWPM_FILTER_CONDITION0 {
                fieldKey: FWPM_CONDITION_IP_LOCAL_PORT,
                matchType: FWP_MATCH_EQUAL,
                conditionValue: FWP_CONDITION_VALUE0 {
                    r#type: FWP_UINT16,
                    Anonymous: FWP_CONDITION_VALUE0_0 {
                        uint16: local_port,
                    },
                },
            });
            println!("‚úì Êú¨Âú∞Á´ØÂè£Êù°‰ª∂Â∑≤Ê∑ªÂä†: {}", local_port);
        }
        
        // Ê∑ªÂä†ËøúÁ®ãÁ´ØÂè£Êù°‰ª∂
        if let Some(remote_port) = rule.remote_port {
            conditions.push(FWPM_FILTER_CONDITION0 {
                fieldKey: FWPM_CONDITION_IP_REMOTE_PORT,
                matchType: FWP_MATCH_EQUAL,
                conditionValue: FWP_CONDITION_VALUE0 {
                    r#type: FWP_UINT16,
                    Anonymous: FWP_CONDITION_VALUE0_0 {
                        uint16: remote_port,
                    },
                },
            });
            println!("‚úì ËøúÁ®ãÁ´ØÂè£Êù°‰ª∂Â∑≤Ê∑ªÂä†: {}", remote_port);
        }
        
        // Ê∑ªÂä†ÂçèËÆÆÊù°‰ª∂
        if let Some(protocol) = &rule.protocol {
            let protocol_value = match protocol {
                Protocol::Tcp => 6u8,
                Protocol::Udp => 17u8,
                Protocol::Icmp => 1u8,
            };
            
            conditions.push(FWPM_FILTER_CONDITION0 {
                fieldKey: FWPM_CONDITION_IP_PROTOCOL,
                matchType: FWP_MATCH_EQUAL,
                conditionValue: FWP_CONDITION_VALUE0 {
                    r#type: FWP_UINT8,
                    Anonymous: FWP_CONDITION_VALUE0_0 {
                        uint8: protocol_value,
                    },
                },
            });
            println!("‚úì ÂçèËÆÆÊù°‰ª∂Â∑≤Ê∑ªÂä†: {:?}", protocol);
        }
        
        // Ëé∑ÂèñÊù°‰ª∂Êï∞Èáè
        let num_conditions = conditions.len() as u32;
        
        // Á°ÆÂÆöËøáÊª§Âô®Âä®‰Ωú
        let action_type = match rule.action {
            FilterAction::Allow => FWP_ACTION_PERMIT,
            FilterAction::Block => FWP_ACTION_BLOCK,
        };

        // ÂàõÂª∫ËøáÊª§Âô®ÁªìÊûÑ
        let filter = FWPM_FILTER0 {
            filterKey: GUID::zeroed(),
            displayData: FWPM_DISPLAY_DATA0 {
                name: PWSTR(filter_name.as_ptr() as *mut u16),
                description: PWSTR(filter_desc.as_ptr() as *mut u16),
            },
            flags: FWPM_FILTER_FLAGS(0),
            providerKey: ptr::null_mut(),
            providerData: FWP_BYTE_BLOB {
                size: 0,
                data: ptr::null_mut(),
            },
            layerKey: layer_key,
            subLayerKey: FWPM_SUBLAYER_UNIVERSAL,
            weight: FWP_VALUE0 {
                r#type: FWP_UINT64,
                Anonymous: FWP_VALUE0_0 {
                    uint64: unsafe { &raw mut WEIGHT_VALUE as *mut u64 },
                },
            },
            numFilterConditions: num_conditions,
            filterCondition: if num_conditions > 0 {
                conditions.as_ptr() as *mut _
            } else {
                ptr::null_mut()
            },
            action: FWPM_ACTION0 {
                r#type: action_type,
                Anonymous: FWPM_ACTION0_0 {
                    calloutKey: GUID::zeroed(),
                },
            },
            Anonymous: FWPM_FILTER0_0 {
                rawContext: 0,
            },
            reserved: ptr::null_mut(),
            filterId: 0,
            effectiveWeight: FWP_VALUE0 {
                r#type: FWP_UINT64,
                Anonymous: FWP_VALUE0_0 {
                    uint64: unsafe { &raw mut EFFECTIVE_WEIGHT_VALUE as *mut u64 },
                },
            },
        };

        // Áî®‰∫éÂ≠òÂÇ®Êñ∞Ê∑ªÂä†ÁöÑËøáÊª§Âô®ID
        let mut filter_id = 0u64;
        // Ê∑ªÂä†ËøáÊª§Âô®Âà∞WFPÂºïÊìé
        let add_result = FwpmFilterAdd0(self.engine_handle, &filter, None, Some(&mut filter_id));

        // Ê£ÄÊü•Ê∑ªÂä†ÁªìÊûú
        if WIN32_ERROR(add_result) == ERROR_SUCCESS {
            Ok(filter_id)
        } else {
            println!("‚ùå Ê∑ªÂä†ËøáÊª§Âô® '{}' Â§±Ë¥•: {}", rule.name, add_result);
            Err(Error::from_win32())
        }
    }

    // Ê∑ªÂä†ÁΩëÁªúËøáÊª§Âô®ÁöÑÂÜÖÈÉ®ÊñπÊ≥ïÔºà‰øùÊåÅÂêëÂêéÂÖºÂÆπÔºâ
    unsafe fn add_network_filter(
        &self,
        name: &str,
        layer_key: GUID,
        appid: Option<&[u16]>,
    ) -> Result<u64> {
        // Â∞ÜËøáÊª§Âô®ÂêçÁß∞ËΩ¨Êç¢‰∏∫ÂÆΩÂ≠óÁ¨¶‰∏≤
        let filter_name = to_wide_string(name);
        // ÁîüÊàêËøáÊª§Âô®ÊèèËø∞Âπ∂ËΩ¨Êç¢‰∏∫ÂÆΩÂ≠óÁ¨¶‰∏≤
        let filter_desc = to_wide_string(&format!("ÊéßÂà∂ {} ÁöÑÁΩëÁªúÊµÅÈáè", name));

        // ÂàõÂª∫ËøáÊª§Êù°‰ª∂ÂêëÈáè
        let mut conditions = Vec::new();
        // Â¶ÇÊûúÊèê‰æõ‰∫ÜÂ∫îÁî®Á®ãÂ∫èË∑ØÂæÑÔºåÊ∑ªÂä†Â∫îÁî®Á®ãÂ∫èIDÊù°‰ª∂

        if let Some(appid_utf16) = appid {
            let app_id = FWP_BYTE_BLOB {
                size: (appid_utf16.len() * 2) as u32,
                data: appid_utf16.as_ptr() as *mut u8,
            };

            // Ê∑ªÂä†Â∫îÁî®Á®ãÂ∫èIDÂåπÈÖçÊù°‰ª∂
            conditions.push(FWPM_FILTER_CONDITION0 {
                fieldKey: FWPM_CONDITION_ALE_APP_ID, // ‰ΩøÁî®Â∫îÁî®Á®ãÂ∫èIDÂ≠óÊÆµ
                matchType: FWP_MATCH_EQUAL,          // ‰ΩøÁî®Áõ∏Á≠âÂåπÈÖç
                conditionValue: FWP_CONDITION_VALUE0 {
                    r#type: FWP_BYTE_BLOB_TYPE, // ÂÄºÁ±ªÂûã‰∏∫Â≠óËäÇblob
                    Anonymous: FWP_CONDITION_VALUE0_0 {
                        byteBlob: &app_id as *const _ as *mut _,
                    },
                },
            });

            println!("‚úì APP_IDÊù°‰ª∂Â∑≤Ê∑ªÂä†Âà∞ËøáÊª§Âô®");
            println!("========================\n");
        }
        // Ëé∑ÂèñÊù°‰ª∂Êï∞Èáè
        let num_conditions = conditions.len() as u32;

        // ÂàõÂª∫ËøáÊª§Âô®ÁªìÊûÑ
        let filter = FWPM_FILTER0 {
            filterKey: GUID::zeroed(), // ‰ΩøÁî®Á©∫GUID
            displayData: FWPM_DISPLAY_DATA0 {
                // ÊòæÁ§∫‰ø°ÊÅØ
                name: PWSTR(filter_name.as_ptr() as *mut u16),
                description: PWSTR(filter_desc.as_ptr() as *mut u16),
            },
            flags: FWPM_FILTER_FLAGS(0),  // Êó†ÁâπÊÆäÊ†áÂøó
            providerKey: ptr::null_mut(), // Êó†Êèê‰æõËÄÖ
            providerData: FWP_BYTE_BLOB {
                // Á©∫Êèê‰æõËÄÖÊï∞ÊçÆ
                size: 0,
                data: ptr::null_mut(),
            },
            layerKey: layer_key,                  // ËÆæÁΩÆËøáÊª§Â±Ç
            subLayerKey: FWPM_SUBLAYER_UNIVERSAL, // ‰ΩøÁî®ÈÄöÁî®Â≠êÂ±Ç
            weight: FWP_VALUE0 {
                // ËÆæÁΩÆÊùÉÈáç
                r#type: FWP_UINT64,
                Anonymous: FWP_VALUE0_0 {
                    uint64: unsafe { &raw mut WEIGHT_VALUE as *mut u64 },
                },
            },
            numFilterConditions: num_conditions, // Êù°‰ª∂Êï∞Èáè
            filterCondition: if num_conditions > 0 {
                conditions.as_ptr() as *mut _
            } else {
                ptr::null_mut()
            }, // Êù°‰ª∂Êï∞ÁªÑ
            action: FWPM_ACTION0 {
                // ËÆæÁΩÆÂä®‰Ωú‰∏∫ÈòªÊ≠¢
                r#type: FWP_ACTION_BLOCK,
                Anonymous: FWPM_ACTION0_0 {
                    calloutKey: GUID::zeroed(),
                },
            },
            Anonymous: FWPM_FILTER0_0 {
                // ÂéüÂßã‰∏ä‰∏ãÊñá
                rawContext: 0,
            },
            reserved: ptr::null_mut(), // ‰øùÁïôÂ≠óÊÆµ
            filterId: 0,               // ËøáÊª§Âô®IDÂàùÂßãÂåñ‰∏∫0
            effectiveWeight: FWP_VALUE0 {
                // ÊúâÊïàÊùÉÈáç
                r#type: FWP_UINT64,
                Anonymous: FWP_VALUE0_0 {
                    uint64: unsafe { &raw mut EFFECTIVE_WEIGHT_VALUE as *mut u64 },
                },
            },
        };

        // Áî®‰∫éÂ≠òÂÇ®Êñ∞Ê∑ªÂä†ÁöÑËøáÊª§Âô®ID
        let mut filter_id = 0u64;
        // Ê∑ªÂä†ËøáÊª§Âô®Âà∞WFPÂºïÊìé
        let add_result = unsafe { FwpmFilterAdd0(self.engine_handle, &filter, None, Some(&mut filter_id)) };

        // Ê£ÄÊü•Ê∑ªÂä†ÁªìÊûú
        if WIN32_ERROR(add_result) == ERROR_SUCCESS {
            Ok(filter_id) // ÊàêÂäüËøîÂõûËøáÊª§Âô®ID
        } else {
            println!("‚ùå Ê∑ªÂä†ËøáÊª§Âô® '{}' Â§±Ë¥•: {}", name, add_result);
            Err(Error::from_win32()) // Â§±Ë¥•ËøîÂõûÈîôËØØ
        }
    }
}